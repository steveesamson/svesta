var A=Object.defineProperty;var C=(s,t,e)=>t in s?A(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var h=(s,t,e)=>(C(s,typeof t!="symbol"?t+"":t,e),e);import{e as b,_ as D,o as B,$ as O,a0 as E,g as P,W as U,x as F}from"./runtime.Rfn1ujjP.js";import{h as S}from"./disclose-version.BFBkyvOg.js";import{p as I,_ as N}from"./preload-helper.BUg7RPh1.js";function K(s,t,...e){var o,n;b(()=>{o!==(o=s())&&(n&&(O(n),n=null),o&&(n=B(()=>o(t,...e))))},D)}function J(s,t,e){e=e==null?null:e+"";var o=s.__attributes??(s.__attributes={});S&&(o[t]=s.getAttribute(t),t==="src"||t==="href"||t==="srcset")||o[t]!==(o[t]=e)&&(t==="loading"&&(s[E]=e),e===null?s.removeAttribute(t):s.setAttribute(t,e))}function Q(s){if(!S&&s.loading==="lazy"){var t=s.src;s[E]=null,s.loading="eager",s.removeAttribute("src"),requestAnimationFrame(()=>{s[E]!=="eager"&&(s.loading="lazy"),s.src=t})}}const m=new Map,Y=s=>{if(!m.has(s)){const t=I({type:s,data:void 0,error:void 0});m.set(s,t)}return m.get(s)},l={KEY:"NetworkState",save(s){typeof window>"u"||sessionStorage.setItem(l.KEY,s)},restore(){if(typeof window>"u")return!0;const s=sessionStorage.getItem(l.KEY);return s?s==="true":!1}},w=I({online:l.restore()});let R=U(!1);const v=()=>{navigator.onLine?(console.log("online"),w.online=!0,l.save("true"),P(R)&&location.reload()):(console.log("offline"),w.online=!1,l.save("false"))},x=()=>{typeof window>"u"||(window.addEventListener("online",v),window.addEventListener("offline",v),w.online||v())};x();const y={get status(){return w},qeueuRefresh(){F(R,!0)}},q=async s=>{try{const t=await N(()=>import("./index.ChGp7972.js"),[],import.meta.url),{io:e}=t,{BASE_URL:o,DEBUG:n}=s.config,c=e(`${o}`,{transports:["websocket"]});return c.on("connect",function(){s.sync=function(i,f,u){return y.status.online?new Promise(d=>{try{c.emit(f,{path:i,data:u},r=>{const{status:a,body:g}=r,T={status:a,...g||{}};n&&console.log("IO: ","result: ",r,"path: ",i,"method: ",f," args: ",u),d(T)})}catch(r){n&&console.log("IO: ","error: ",r.toString(),"path: ",i,"method: ",f," args: ",u),d({error:r.toString(),status:500})}}):(y.qeueuRefresh(),Promise.resolve({error:"You seem to be offline :)",status:404}))}}),c.on("comets",s.onComets),c}catch(t){console.log("RealTime initialization error: ",t)}},p={},_=s=>async(t,e,o=void 0)=>{if(!y.status.online)return y.qeueuRefresh(),Promise.resolve({error:"You seem to be offline :)",status:404});const{BASE_URL:n,init:c}=s.config;let{fetch:i}=s.config;if(n||console.warn("You did not set the BASE_URL on Transport before invoking methods; this might break your requests. I hope this is deliberate and you are passing url as FQDN plus paths."),!i&&typeof window<"u"&&(i=window.fetch),!i)return Promise.resolve({error:"You seem to be invoking methods on Transport from server; pass down fetch from your view +page.[t/j]s :)",status:500});const f=["post","put"].includes(e.toLowerCase());f||(t=o?[t,new URLSearchParams(o).toString()].join("?"):t);const u=`${n}${t}`,d=f?JSON.stringify(o||{}):void 0;s.loading.data=!0;try{const r={...c,method:e,body:d},a=await i(u,r),g=a.status;if(!a.ok){const L=`${t} - ${a.statusText}`;return console.log("Error: ",L),{error:L,status:g}}return{...await a.json(),status:g}}catch(r){const a=r.toString();return console.log("Fetch error: ",a),{error:"Fetch error",status:500}}};class k{constructor(t){h(this,"loading",Y("loading"));h(this,"cometListeners",{});h(this,"config",{BASE_URL:"",DEBUG:!1,realTime:!1,fetch:typeof window>"u"?void 0:window.fetch,init:{method:"GET",mode:"cors",credentials:"same-origin",headers:{"Content-Type":"application/json; charset=UTF-8"}}});h(this,"socket",null);this.config={...this.config,...t}}async fetch(t,e,o=void 0){return _(this)(t,e,o)}async sync(t,e,o=void 0){return _(this)(t,e,o)}destroy(){this.sync=_(this),this.socket=null}async switchToRealTime(){const{realTime:t}=this.config;t&&!this.socket&&(this.socket=await q(this))}onCometsNotify(t){const e=this.cometListeners[t.store]||[];e.find(o=>o.listenerID===t.listenerID)||(e.push(t),this.cometListeners[t.store]=e)}stopCometsOn(t){const e=this.cometListeners[t.store]||[];if(!e.length)return;const o=e.filter(n=>n.listenerID!==t.listenerID);this.cometListeners[t.store]=o}onComets(t){const{DEBUG:e}=this.config;e&&console.log("IO: ","oncomets: ",t.room,t.verb,t.data);const o=this.cometListeners[t.room]||[];o.length&&o.forEach(n=>n.onComets(t))}async upload(t,e){return await this.fetch(t,"POST",e)}async post(t,e){return await this.fetch(t,"post",e)}async get(t,e){return await this.fetch(t,"get",e)}async patch(t,e){return await this.fetch(t,"patch",e)}async put(t,e){return await this.fetch(t,"put",e)}async options(t,e){return await this.fetch(t,"options",e)}async delete(t,e){return await this.fetch(t,"delete",e)}}const $=new k({});p.default=$;const V={configure(s){const{context:t="default",...e}=s,o=new k(e);return p[t]=o,o},instance(s){if(["string","undefined"].includes(typeof s)){const t=s||"default",e=p[t];if(!e)throw Error("Invalid transport context: "+t);return e}else{const{fetch:t,context:e="default"}=s,o=p[e];if(!o)throw Error("Invalid transport context: "+e);return o.config.fetch=t,o}}};export{V as T,J as a,Q as h,y as n,K as s};
